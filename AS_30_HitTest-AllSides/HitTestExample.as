/*This is an example of preventing the hero from crossing into multiple/dynamic barriers*/package  {		import flash.display.MovieClip;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;		public class HitTestExample extends MovieClip {		private var hero:MovieClip;		private var barriers:Array;		var barrier:MovieClip;		var dir:int;				public function HitTestExample() {			// constructor code			barriers = new Array();						// CREATE AS MANY BARRIES AS YOU NEED			barriers[0] = createNewObject(50,100,Math.random()*400,200,0x0000FF);			barriers[1] = createNewObject(50,100,140,100,0x0000FF);			barriers[2] = createNewObject(50,100,450,Math.random()*400,0x0000FF);						// HERO CREATION			hero = createNewObject(50,50,200,400,0xFF0000);						// GAME LOOP			addEventListener(Event.ENTER_FRAME, loop);			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPress)			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyRelease)		}				// HIT TEST FUNCTION		function hitTest(obj1:MovieClip, obj2:MovieClip, offset:int){			if(/* top */ obj2.y+(obj2.height*.5) > obj1.y - (obj1.height *.5)			   /* bottom */ && obj2.y-(obj2.height*.5)<obj1.y+(obj1.height*.5)			   /* left */ && obj2.x+(obj2.width*.5)>obj1.x-(obj1.width*.5)			   /* right */&& obj2.x-(obj2.width*.5)<obj1.x+(obj1.width*.5)){			   	obj1.alpha = .3							// THIS PREVENTS THE HERO FROM ENTERING INTO THE BARRIES				// IT'S BASED OFF OF THE DIRECTION THAT YOU'RE COMING FROM...				// ... TO PREVENT DOUBLE HIT TESTS								switch(dir){				case Keyboard.DOWN:					if(obj2.y+(obj2.height*.5) > obj1.y - (obj1.height *.5)					   && obj2.y<obj1.y ){						trace("top");						obj2.y=obj1.y-(obj1.height*.5)-(obj2.height*.5)					}				break;								case Keyboard.UP:					if(obj2.y-(obj2.height*.5)<obj1.y+(obj1.height*.5)						  && obj2.y-(obj2.height*.5)>obj1.y+(obj1.height*.5)-(obj2.height*.5)-offset){						obj2.y=obj1.y+(obj1.height*.5)+(obj2.height*.5);						trace("bottom");					}				break;								case Keyboard.RIGHT:					if(obj2.x+(obj2.width*.5)>obj1.x-(obj1.width*.5)						&& obj2.x+(obj2.width*.5)<obj1.x-(obj1.width*.5)+(obj2.width*.5)+offset){						trace("left")						obj2.x=obj1.x-(obj1.width*.5)-(obj2.width*.5);					}				break;									case Keyboard.LEFT:					if(obj2.x-(obj2.width*.5)<obj1.x+(obj1.width*.5)						  && obj2.x-(obj2.width*.5)>obj1.x+(obj1.width*.5)-(obj2.width*.5)-offset){						trace("right")						obj2.x=obj1.x+(obj1.width*.5)+(obj2.width*.5);					}				break;				}							}else {				obj1.alpha = 1;							}		}				// EVENT HANDLERS		function onKeyPress(e:KeyboardEvent):void{			switch(e.keyCode){				case Keyboard.RIGHT:				dir = Keyboard.RIGHT;				break;								case Keyboard.LEFT:				dir = Keyboard.LEFT;				break;								case Keyboard.UP:				dir = Keyboard.UP;				break;								case Keyboard.DOWN:				dir = Keyboard.DOWN;				break;							}		}		function onKeyRelease(e:KeyboardEvent):void{			dir = 0;		}		private function loop(e:Event):void{			// DIRECTION IS IN LOOP TO FIX THE PRESS AND WAIT FLASH PROBLEM			switch(dir){				case Keyboard.RIGHT:				hero.x+=5;				break;								case Keyboard.LEFT:				hero.x-=5;				break;								case Keyboard.UP:				hero.y-=5;				break;								case Keyboard.DOWN:				hero.y+=5;				break;			}						// hit test hero against the barriers			// this would be better in a loop, but for ease of direction... 			// ...relastionships each barrier is typed out longhand						hitTest(barriers[0], hero, 5)			hitTest(barriers[1], hero, 5)			hitTest(barriers[2], hero, 5)								}		// UTILITY FUNCTION TO CREATE OBJECTS		private function createNewObject(h:int, w:int, xp:int, yp:int,color:uint):MovieClip{			var mc:MovieClip = new MovieClip();			mc.graphics.beginFill(color);			mc.graphics.drawRect(w*-.5,h*-.5,w,h);			mc.x = xp;			mc.y = yp;			addChild(mc);			return mc;		}	}	}		